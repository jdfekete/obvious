\label{sec:viewvis}
Unlike the data model, no consensus emerged concerning the
Visualization and View models during the
workshop~\cite{vismaster2008}; the main reason being the different
approaches chosen among toolkits.  One important issue is the
monolithic vs. polylithic approach. Another one is related to tables
vs. objects: some toolkits keep the visualization data in tables
(e.g. Prefuse, IVTK, and Tulip) whereas others create
objects for displaying (e.g. Improvise, Cytoscape) or nothing at all
when there is a pipeline as in Discovery.  So, more work is needed to
design the abstractions required to wrap the different
implementations.  Further discussions and workshops will address the
problem.

Still, Obvious provides a solution: it wraps visualizations into a
black box with a small set of methods and --- for the creation of
these visualizations --- it relies on a \emph{Factory} design
pattern~\cite{DesignPatterns}.  For example, creating a scatter-plot
visualization from a data table requires the following lines:
\lstset{frame=single,columns=flexible,numbers=left,numberstyle=\tiny,basicstyle=\small,language=Java,caption={Creating a
    visualization using a Factory},label=factory1}
\begin{lstlisting}
Map params = new HashMap();
params.put("x", "id");
params.put("y", "age");
Visualization vis = VisualizationFactory.getInstance()
    .createVisualization(table, null, "scatterplot", params);
\end{lstlisting}
The variable ``param'' contains parameters to configure the
visualization, here to specify which attribute will be used for the $x$
and $y$ axes.

With this mechanism, it looks as if Obvious were a monolithic toolkit
but the actual implementation of the Obvious wrapper for a polylithic
toolkit can easily translate a monolithic specification into a
dedicated configuration for the underlying polylithic component.  The
code above will work for the Prefuse toolkit and return a polylithic
component wrapped as an Obvious visualization and configured as a
scatter-plot visualization.

If a developer needs a visualization component that does not exist in
the default implementation (e.g. an IVTK time-series with a
Prefuse-wrapped data table), the visualization can be created directly
from a specified factory or from the Obvious class:\\
\lstinline!new IvtkTimeSeriesVis(table, null, "timeseries", params)!

%% \jo{Can we sure about the last sentence above?. The discussion of
%%   Prefuse in 6.1 is an example of this, but requires the user of
%%   Prefuse to develop new visualization components and wrap them in
%%   Obvious. This seems like an 'extra cost of development' to me.}
%% \pierreluc{Wrap them in Obvious is pretty easy (about ten lines of
%%   code). So yes, there is a tiny extra cost of development.}

An Obvious visualization works with any Obvious data model.  The data
model will be either wrapped to become compatible with the native
model if the underlying implementations are different or unwrapped
when the visualization and the data model are from the same
implementation (e.g. Prefuse).

This mechanism avoids copying data from one structure to another,
which is a crucial point for VA.  Alternatively, Obvious
also provides a default mechanism to quickly copy and synchronize data
models when no wrapper has been defined for a specific toolkit.
Current wrappers are lightweight, adding very little overhead to the
system.

At this point, the application developer can choose one of the
existing visualizations from one of the wrapped toolkits or decide to
create a new one which can derive from one of the wrapped toolkits or
be implemented from scratch.  Obvious substantially increases the
number of possible visualizations and toolkits to use and does not
limit the developer in any way at this stage.

A \emph{View} is simply specified as a black box implementing a
simplified version of the camera pattern introduced in
\cite{DesignPatternsIV} to support standard operations such as zoom
and pan.  Like the visualization interface, future workshops should
enrich it when a more consensuses are reached.

%\jo{The assertion made in this section suggests that the mono/poly-lithic approaches that vary between existing toolkits have less of an impact on data models than on view models. We should probably make some reference to this distinction in Section 2 so that it does not look like we simply ran out of time in the workshop to consider standardization of view models.}
