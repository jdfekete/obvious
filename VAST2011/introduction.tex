%% -*- mode: LaTeX; -*-

Over the past few years, several information visualization (InfoVis)
toolkits have flourished in various languages such as
Java~\cite{Discovery2,InfoVis, Prefuse, jung2003, Improvise},
C++~\cite{Tulip,ADVIZOR}, Flash/Flex~\cite{Axiis,flare} or
JavaScript/HTML5~\cite{thejit,Protovis} to name a few.  When starting
a visual analytics (VA) project, the choice of the toolkit is a major
initial decision and the resulting proliferation of toolkits can be confusing
for VA software developers who know that an
inappropriate choice can lead to unanticipated limitations during the
development of the application.

Historically, this proliferation of toolkits can be explained by
several factors: each created toolkit addresses a specific set of
problems, is designed with a specific application domain in mind, or
simply offers different tradeoffs.  However, it results in dispersion
in terms of capabilities since each toolkit has unique and useful
techniques for visualization and interaction.  For example, the
Prefuse~\cite{Prefuse} and JUNG~\cite{jung2003} toolkits offer several
graph layout algorithms whereas Improvise~\cite{Improvise} supports
very sophisticated coordinated views with limited graph capabilities.

The choice of an InfoVis toolkit should be made
early in the software development process because it affects not only the visualization techniques but
also the data structure to work with.  For an application dealing with
small quantities of data, copying data from one structure to another
is possible in interactive time but not for VA
applications that usually manage data sets too large to be duplicated
at all.  Therefore, most data-management and analysis will be made on
data structures compatible with the visualization and tied to the
visualization toolkit.

%\jo{changed language in the following paragraph to emphasise that this is a consequence of a lack of meta-toolkit/interface rather than advice.}

Once the choice is made, any missing components have to be added
specifically to the toolkit: if a special data manager is required
(e.g., reading a particular data format), it has to be implemented
specifically for the data structure managed by the toolkit. Any analysis
not supported by the toolkit requires the authoring or adaptation of
analytical toolkit components. Likewise, if visualization techniques
are required that are not supported by the chosen toolkit they must
be added, creating a strong dependency that usually prevents changes
of toolkit later-on in the development.

The effort required by one application to implement the missing
components cannot easily be reused in other applications that are based on another
toolkit.  Therefore, important resources are wasted for the re-implementation of
data converters, analysis modules, and visualization techniques. 

To address this proliferation problem, this article introduces
\emph{Obvious}: a meta-toolkit that abstracts and encapsulates InfoVis
toolkits implemented in the Java language as a way to unify their use
and postpone the choice of which concrete toolkit(s) to use later-on
in the development process.  Obvious is mainly targeted at VA software
developers, but also  library or toolkits developers if they want to
promote sharing of data managers, converters, or algorithms not
restricted to one toolkit.

This article presents three contributions:
\begin{enumerate}[noitemsep]
\item it describes the design and implementations of Obvious,
\item it reports some lessons learned when wrapping existing toolkits
  with Obvious, and
\item it presents rationales for the social process we started and
  want to follow for the future of Obvious.
\end{enumerate}

The main benefits offered by Obvious are:
\begin{enumerate}[noitemsep]
\item it improves the reusability of code and components;
\item it improves the interoperability of code, data models and
  visualizations;
\item it defers the choice of which concrete toolkits to use to a
  later stage of the VA development;
\item it enforces a better separation of concerns in VA
  applications so that the data models can be specified independently
  of the visualizations and views;
\item it allows toolkit and library developers to easily integrate
  their tool into the rich environment of Obvious-compatible systems;
\item it clarifies issues with notification and allows VA to scale up using a standard architecture; and
\item it specifies a set of interfaces and a stable vocabulary which
  simplifies learning.
\end{enumerate}

\begin{comment}
Obvious is implemented in a modular way with an abstract core module
and additional specific bindings, implemented for several toolkits:
the Infovis toolkit~\cite{InfoVis}, Prefuse~\cite{Prefuse},
Improvise~\cite{Improvise} and Jung~\cite{jung2003}.  These bindings
have been used to build some proof-of-concepts examples combining
different toolkits and also to create complete systems used by ongoing
research projects such as~\cite{BENZAKEN:2011:INRIA-00532552:1}.

During the development of bindings, we have seen important design
questions emerge regarding the interpretation of the reference model;
we report them here to help clarify the InfoVis reference model and
trade-offs in its implementation.

In addition, Obvious allows developers to eliminate the crucial choice
of the toolkit and to avoid rewriting existing functionalities such as
file import and export modules, as well as analytical algorithms. The
following use case shows it is now possible to combine toolkits.  For
example, they can choose a data model from JUNG toolkit for a graph,
then query it with Prefuse predicates, use a layout introduced in
Infovis toolkit to display it and still used network algorithms
introduced in JUNG.  With obvious, there are no more design restrictions
imposed by an initial choice for developer.


%\subsection{Goals and Social Process}

Obvious is not another toolkit, it is a set of interfaces that
abstract the services provided by InfoVis toolkits
implemented according to the InfoVis reference
model~\cite{ChiRefModel,ReadingsIV}.  Obvious has been specified
during a workshop gathering several major authors of
toolkits~\cite{vismaster2008}; its interfaces have reached a consensus
at the time of the workshop among the developers.  However, they do
not cover all the parts of the reference model evenly.  The data
component is much more precisely defined than the visualization and
view components. 

In the related work section, we describe several models that have been
used to standardize software 

%\subsection{Targeted uses}

A typical scenario of Obvious would be the design of
VizTree~\cite{lin01}, a VA application for monitoring
massive time-series.  VizTree encodes very long time-series of a
continuous value as a suffix tree; the details of this encoding being
beyond the scope of the paragraph scenario.  The associated tree
visualization has been implemented by specialists of data-mining and
leaves room for improvements in term of visualization and
interaction.  Using Obvious, the authors would first connect their
computed data structure to the data model of Obvious. There are two
ways of doing that: use the Obvious data-model directly or use the
native data-model implemented for mining the time-series and wrap it
with an implementation of the Obvious data-model. Both are possible
and will be chosen according to the amount of work and flexibility
offered by one option or the other. Once an Obvious data-model is
available, the authors of VisTree can start exploring which toolkit
will provide them the best support for their visualization. They can
choose among the InfoVis Toolkit, Prefuse and JUNG to visualize tree
data. Once the best one has been chosen, the interaction can be
crafted either on top of the abstraction provided by Obvious - to keep
the option of switching the final implementation - or using the native
toolkit controls to keep a tighter control of the interface. If
desired, the interface can also be improved by adding other
visualizations associated with the computation of the prefix tree or
of statistics associated with the data. If multiple-coordinated views
are required for that, Improvise visualization and views can be added
to the interface using the same data model. In that scenario, Obvious
has enabled data-mining researchers to focus on their skills and to
use state-of-the-art visualization components at a later stage of the
development of their application.

Another scenario [DDupe]

Yet another, more futuristic scenario: porting a new visualization type to multiple toolkits
or allowing cross-toolkit brushing interaction.

\end{comment}

The article is organized as follows: in section 3, after the related
work section, we describe the design of Obvious. Section 4 reports on
the wrapping of several toolkits and components with Obvious. Section
5 shows examples of Obvious in action to assess its
usefulness. Section 6 discusses the social process we have used and
how we envision the evolution of Obvious before concluding.
