This section describes the implementation of Obvious and points the
lessons learned during implementations binding Obvious interfaces to
wrappers around concrete toolkits.  Each toolkit has its own design
choices that are discussed in articles but some of the implications
came to light when implementing the bindings, for example differences
of interpretations of design patterns.  We briefly describe the most
important lessons here.

The core of Obvious is a small (40Kb) Java
project\footnote{\url{http://code.google.com/p/obvious}} managed by
Maven~\cite{Maven} to facilitate its deployment.  It consists in 44
java files, 23 interfaces and 21 utility classes organized in 5
top-level packages: data, viz, view, util and impl.  It has been
designed to be small and lightweight.  Therefore, the substantial
parts are in each concrete toolkit binding.

\subsection{Prefuse}

Prefuse was the first binding implemented because its architecture is,
by design, very close to Obvious.  The binding implements all the
abstractions described in the core Obvious interfaces for all data
models, visualizations and views.

For the visualization, Prefuse is currently the only polylithic
Information Visualization toolkit with a binding for Obvious.  As
explained in~\ref{sec:viewvis}, Obvious does not offer a visualization
abstraction for polylithic components.  Thus, Obvious provides
components pre-configured for well know visualization techniques such
as scatter-plots or force directed graphs.  Currently, if a software
developer wants visualize an Obvious table using a Prefuse
visualization not offered in the Obvious visualization factory, the
only requirement is to convert the data model to a Prefuse data table
using an obviousx component.  

%% [jdf] we never mentioned predicates
%% Prefuse have also been used to implement and test predicates for all
%% the implementations of the Obvious data model. Since an Obvious tuple
%% can easily be wrapped into a Prefuse one, the first Obvious predicate
%% implementation is based on Prefuse predicate engine and its syntax.

Several interfaces defined by Obvious are based on a Prefuse concrete
class.  Therefore, Prefuse was used as a complete implementation of
Obvious to check its model and syntax.

%% This demonstrates that creating an implementation of Obvious allows
%% other implementations to benefit of new features. It is one of the
%% main goal of Obvious: binding toolkits to extend their capabilities.
\jdf{Add size of obvious-prefuse and size of prefuse}

\subsection{InfoVis Toolkit}

Since the InfoVis Toolkit is monolithic and follows the reference
Information Visualization model, its Obvious binding realizes all the
interfaces for the data model, visualization and view introduced in
Obvious. The InfoVis Toolkit has monolithic visualizations, providing
them simply consists in wrapping an Obvious visualization around them
class and implementing a factory to create them by name.

However, the data model of the InfoVis Toolkit differs from Obvious
for trees and networks: in the InfoVis Toolkit, the Graph interface is
not a super-interface of the Tree interface.  In addition, some data
model classes are more specialized in the InfoVis Toolkit than in
Obvious.  For example, tables can be described as static tables or
dynamic tables.  The binding was therefore complicated by these
mismatches that needed a more complicated code than for Prefuse.

Nevertheless, the InfoVis Toolkit binding is operational and
reliable.

\jdf{Add size of obvious-ivtk and size of ivtk}

\subsection{Improvise}

Currently, the Obvious implementation based on Improvise only
implements the data model part for tables.  Even if Improvise is a
monolithic toolkit, Obvious cannot directly bind Improvise
visualization components because the toolkit does not expose its
visualization pipeline publicly: Improvise components are intended to
be complete black boxes.  Addressing this problem would require some
changes inside the current version of Improvise. In addition,
Improvise does not support well dynamic data, which is a functionality
intended to be in every obvious implementation.

Currently, Improvise can use a data table from an Obvious data table
but the rest of the Improvise pipeline is hidden from
Obvious. Providing a complete binding for Improvise in Obvious would
require some changes in Improvise.

\jdf{Add size of obvious-improvise and size of Improvise}

\subsection{JDBC}

JDBC is the standard Java interface to standard SQL databases.  We
wrapped JDBC in an Obvious data table to prove that Obvious can
support a large variety of data model, not only models coming from
information visualization toolkits.  JDBC was chosen because databases
are frequently used as data sources for applications and since JDBC
provides additional features not available in the toolkits data tables
such as atomic and batched transactions.  We used it to test the
notification model introduced formerly.  As expected, this
implementation only supports the data model of Obvious.

Concretely, this implementation translates obvious methods into SQL
queries.  For example, the data table ``get'' methods are implemented
as SELECT queries, the ``set'' methods as UPDATE queries, the ``add''
methods as INSERT queries, and the ``remove'' methods as DELETE
queries.  Queries are written in standard SQL and several applications
have been written to work with different DBMS such as MySQL and
Oracle.  In addition, for the notification system, table listeners
compatible with transaction and batch strategies presented in
\ref{sub:combiningnotif} have been developed and help validate the
Obvious notification model.

\jdf{Add size of obvious-jdbc and size of jdbc binding (oracle + mysql)}

\subsection{JUNG}

JUNG is a graph library in Java that mainly manages the graph topology
but associates arbitrary attributes with vertices and edges.
Concretely, this implementation realizes all interfaces defined in
Obvious, except for tables and schemas since these notions do not
exist in JUNG.  Schemas are mandatory in Obvious, so this
implementation uses a default schema implementation from the obvious
core package.  The network structure of Obvious is similar to JUNG's
graph; therefore, the data model of JUNG was easy to wrap as an
Obvious Network.  Concerning the visualizations and views, JUNG
provides monolithic visualizations.  The Obvious implementation simply
binds existing JUNG visualization components to Obvious visualizations.

This implementation was the easiest to create since Obvious and JUNG
share common hypotheses: for their data model (Obvious network and
JUNG graph are equivalent) and JUNG and Obvious are both compatible
with the monolithic approach.  

\jdf{Add size of obvious-jung and size of jung}

\subsection{Units tests}
\label{sub:unittests}

Obvious is specified using Java interfaces and some comments in the
implementation files but without any formal specification of the
precise behavior of the defined interfaces.  To verify that all the
implementations behave correctly and consistently, we have implemented
\emph{Unit Tests}: a suite of classes and methods aimed at testing all
the methods of all the classes.

Currently, the tests are only defined on the data model of Obvious.
The level of specification of Obvious visualizations and views is not
sufficient to perform useful tests.

Unit tests need an implementation to work; they cannot test abstract
classes or interfaces.  Due to the similarities of Obvious and
Prefuse, the Prefuse binding has been used to set up the unit tests
for the data model of Obvious.  They have then been moved to the core
Obvious module to be usable by all the bindings.  Unit tests allow
authors of Obvious bindings to automatically test whether their
implementation behaves in conformance with the intended semantics of
Obvious.  Also, authors are able to extend these existing tests in
their own module to perform more advanced ones for their binding.

Concretely, unit tests have been defined with JUnit~\cite{JUnit} for
the following interfaces: Schema (14 tests), Table (11 tests), Network
(13 tests) and Tree (8 tests); all part of the Obvious core package.
These tests have been systematically run for each new Obvious data
model development: all presented implementations successfully passed
those tests.


%\subsection{Lessons learned}

With the exception of Improvise, all the toolkits we wanted to support
are now available with Obvious.  The extra code required for binding a
concrete toolkit is quite modest compared to the toolkit itself and
the overhead in time has always been negligible.  At this point,
Obvious is usable with a wide range of concrete implementations and we
report on its uses in the next section.

\begin{table}[h]
\caption{\label{tab:obviousfootprint} Footprint of Obvious bindings}
\small
\begin{tabular}{|p{\tableCol}|p{\tableCol}|p{\tableCol}|p{\tableCol}|p{\tableCol}|}
    \hline
    \textbf{Bindings} & \textbf{obvious.data} & \textbf{obvious.vis} & \textbf{obvious.view} & \textbf{JAR} \\
    \hline
    \textit{Prefuse} & 10 classes \newline(1235 lines) & 7 classes \newline(446 lines) & 2 classes \newline(94 lines) & 120 kB \\
    \hline
    \textit{Infovis} Toolkit & 6 classes \newline(1404 lines) & 5 classes \newline(460 lines) & 1 class \newline(105 lines) & 115 kB \\
    \hline
    \textit{Improvise} & 3 classes \newline(519 lines) & None & None & 27 kB \\
    \hline
    \textit{JDBC} & 8 classes \newline(1936 lines) & None & None & 75 kB \\
    \hline
    \textit{JUNG} & 3 classes \newline(714 lines) & 1 class \newline(139 lines) & 2 classes \newline(114 lines) & 93 kB \\
    \hline
\end{tabular}
\normalsize
\end{table}
\begin{comment}

+++ revise

We have learned several lessons during the development of Obvious
bindings:
%implementations: mainly concerning lack of precision in the
%Information Visualization reference model. We can list the following
%lessons:

\begin{itemize}
\item the need for a specification of a clear semantic for the
  notifications; the notification model can support simple models and
  more advanced ones (with batches and transactions for example)
\item the need for support for a polylithic approach to define an
  abstraction model for visualizations
\item the more abstractions defined the more unit tests we can define
  to validate new implementations
\item toolkits need to adopt patterns close to Obvious ones in order
  to enhance code quality of the implementations and to facilitate the
  sharing of functionalities among existing toolkits 
\end{itemize}

\jo{The last itemized point above seems like an important one, and one we should revisit in the conclusion. It exposes the issue of the degree to which existing toolkits need to adapt to allow interoperability through Obvious. It is good that we are honest about this, but it does seem to be a significant weakness with the approach, especially if we wish to support VA that use data structures that don't fit well into those modelled in Obvious (e.g. geospatial Rasters, fuzzy sets).}


\end{comment}

