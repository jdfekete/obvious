This section points out encountered difficulties, raised problems and learned lessons during implementations of Obvious. Each implementation has its own particularities and allows  to better identify gaps in existing design patterns and models. Thus, we start by describing specific points in realized implementations and then we conclude with lessons learned during the whole step of implementation.

\subsection{Prefuse}

Prefuse was the first targeted implementation of Obvious since its design patterns are very close to those of Obvious.  The binding implements all abstractions described in the core Obvious interfaces for all data model structures, visualizations, views.

Prefuse is currently the only polylithic Information Visualization toolkit used with Obvious. However, Obvious does not currently offer a visualization abstraction for polylithic components since no consensus has emerged yet. Thus, we choose to provide some pre-built monolithic components based on Prefuse for well know visualization techniques such as scatter plots, force directed graphs, radial graphs... Currently, if a software developer wants to use a non existing technique, he has to write it with Prefuse as a component and wrap it with the Obvious visualization interface. Prefuse have also been used to introduce predicate support for all existing implementations of the Obvious data model. Since an Obvious tuple can easily be wrapped into a Prefuse one, the first Obvious predicate implementation is based on Prefuse predicate engine and its syntax.

This demonstrates that creating an implementation of Obvious allows other implementations to benefit of new features. It is one of the main goal of Obvious: binding toolkits to extend their capabilities. 

\subsection{Infovis Toolkit}

Since the Infovis Toolkit is monolithic and follows the reference Information Visualization model, this implementation can realize all interfaces for the data model, visualization and view introduced in Obvious.

That is why unlike the Obvious implementation for Prefuse, to create Obvious visualization component, it is simply needed to wrap existing monolithic component of Infovis Toolkit. However, the data model of Obvious and the one of Infovis Toolkit are different: both models do not share the same object relationships -for example, in Infovis Toolkit the Graph interface is not a superinterface for the Tree interface-. In addition, data model classes are more specialized in Infovis Toolkit and do not offer the same granularity for method than in Obvious: for instance, tables can be described as static tables or dynamic tables. Thus, to implement the Obvious data model for Infovis Toolkit, some complementary code that plays with existing methods in the Infovis Toolkit was needed and so complicates the development and the maintenance of the implementation.

\subsection{Improvise}

Currently, the Obvious implementation based on Improvise only implements the data model part -for tables-.

Even if Improvise is a monolithic toolkit, we cannot directly bind Improvise visualization components, since the toolkit does not expose its visualization pipeline publicly. Components are intended to be totally monolithic from scratch. To address those problems, a solution to expose the visualization pipeline is to create in Improvise a specific visualization interface making public needed methods. In addition, Improvise does not provide dynamic data support: a functionality intended to be in every obvious implementation.

Thus, this implementation shows that \emph{coevolution} between Obvious and existing toolkits is needed to apply abstractions.

\subsection{JDBC}

This implementation is built to prove that Obvious can handle a large variety of data model and not only models coming from information visualization toolkit. JDBC was chosen in this purpose since databases are often used as a data source for applications and since the others toolkits we use to create implementation do not support functionalities such as transactions to test the notification model introduced formerly. Logically, this implementation only supports the data model of Obvious.

Concretely, this implementation  translates obvious methods into SQL queries. For example, getters are implemented as SELECT queries, setters as UPDATE ones, add as INSERT queries and remove as DELETE queries. Queries used are written in "`standard"' SQL and the implementation has been tested (with tests introduced in \ref{sub:unittests}) and several applications have been written on different DBMS such as MySQL and Oracle. In addition, for the notification system, table listeners compatible with transaction and batch strategies presented in \ref{sub:combiningnotif} have been developped to validate it.

Finally, this implementation shows one interest of Obvious: its abstraction can be applied to different fields than information visualization and it is another way to extend capabilities of all Obvious implementations.

\subsection{JUNG}

The motivation to create an Obvious implementation based on JUNG is that others implementations concern applications and data structures agnostic toolkits (Prefuse and Infovis Toolkit). Thus, JUNG, a toolkit dedicated to graph structure, is a good candidate to test abstractions introduced in Obvious on another kind of toolkit. 

Concretely, JUNG implementation of Obvious realizes Visualization and View patterns and the Network abstraction, because JUNG already follows this pattern and does not have the notion of table. Since JUNG can easily provides monolithic visualizations , we simply bind existing JUNG visualization components to Obvious ones. As JUNG does not offer schema class, we use a predefined schema implementation from obvious core package to respect our patterns.

From all existing implementations, this one was the easiest to create, since it fits well in Obvious assumptions (network pattern for the data model and easily providing monolithic components). Thus, it demonstrates when an existing toolkit and obvious have the same (or close)  hypotheses, it greatly facilitates implementation.

\subsection{Units tests}
\label{sub:unittests}

Since we have defined a consensual abstraction for the data model, we take advantage of this consensus to create unit tests for this abstraction. If such a consensus emerges for the visualization and/or the view part, the same approach could be adopted.

Due to the similarities of Obvious and Prefuse, the binding has been used to set up unit tests for the data model in Obvious. Unit tests allow authors of Obvious bindings to automatically test whether their implementation behaves in conformance with the intended semantics of Obvious. Also, authors are able to extend these existing tests to perform more advanced features for their binding.

Concretely , unit tests have been defined with JUnit  for Schema (14 tests) , Table (11 tests), Network (13 tests) and Tree interfaces (8 tests) in the Obvious core package. These tests have been systematically run for each new Obvious data model development: all presented implementations successfully passed those tests.

\subsection{Lessons learned}

We have learned several lessons during the development of those implementations: mainly concerning lack of precision in the Information Visualization reference model. We can list the following lessons:

\begin{itemize}
\item the need for a specification of a clear semantic for notifications that can support simple models and more advanced ones (with batches and transactions for example)
\item the need for support for a polylithic approach to define an abstraction model for visualizations
\item the more abstractions defined the more unit tests we can define to validate new implementations
\item toolkits need to adopt patterns close to Obvious ones in order to enhance code quality of the implementations and to facilitate the sharing of functionalities among existing toolkits
\end{itemize}

\jo{The last itemized point above seems like an important one, and one we should revisit in the conclusion. It exposes the issue of the degree to which existing toolkits need to adapt to allow interoperability through Obvious. It is good that we are honest about this, but it does seem to be a significant weakness with the approach, especially if we wish to support VA that use data structures that don't fit well into those modelled in Obvious (e.g. geospatial Rasters, fuzzy sets).}


